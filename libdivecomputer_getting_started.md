# Installation

On windows use [these](http://www.libdivecomputer.org/builds/divinglog/) DLLs. The headers and other files can be generated by building the libdivecomputer as seen below.

## Prerequisites

To build on windows you need MinGW base tools and msys tools. Ensure it has autoreconf as tool available and a gcc compiler. Normally you also need libusb-hidapi as a library installed, but we will download the precompiled DLLs later so we  don have to do this.

For linux you would need hidapi. If `/usr/lib/pkgconfig/hidapi.pc` isn't created: copy (or link) `/usr/lib/pkgconfig/hidapi-libusb.pc` to `/usr/lib/pkgconfig/hidapi.pc`.

## Building

The libdivecomputer sources which can be downloaded from their [git repo](https://github.com/libdivecomputer/libdivecomputer). 


- Open a msys terminal (found in the msys installation folder).
- Navigate to the libdivecomputer sources
- call `autoreconf --install` . If you don't have autoreconf, install it, for windows it should be in the msys base package.
- the previous step should have generated a `./configure` script, call it `./configure`
- Now we can call `make` 
- Lastly `make install` to install it.

The made library are available in `/usr/local/lib` and headers in `/usr/local/include/`. For windows, replace the DLLs with the DLLs from [these](http://www.libdivecomputer.org/builds/divinglog/). The pre-compiled DLLs are compiled against libusb-hidapi, which are a pain to get working on windows.

## Linking

To link use `-ldivecomputer`. To link locally use `-L{PATH_TO_LIB} -ldivecomputer`.

# Usage

## Overview

Using libdivecomputer you can extract data from various divecomputer devices. The general process follows these steps:

1. Creating a context for logging and error handling
2. Selecting the descriptor for your dive computer
3. Selecting and the transport to interface with your device
4. Selecting a transport device 
5. Opening communications to that transport, called an iostream
5. Opening communications to the dive computer
6. Downloading data from your device
7. Parsing the the data to a more usable state
8. Cleanup

## Common patterns

This section describes some common patterns used throughout this library.

### `dc_status_t` as return value

Most functions return a status of the `dc_status_t`, this indicates whenever or not the operation succeeded. It can hold the following values

- `DC_STATUS_SUCCESS`: the operation succeeded
- `DC_STATUS_DONE`: End of an iterator
- `DC_STATUS_UNSUPPORTED`: Operation not supported by current device
- `DC_STATUS_INVALIDARGS`: Invalid arguments given to the function
- `DC_STATUS_NOMEMORY`: Memory allocation failed
- `DC_STATUS_NODEVICE` Device not found
- `DC_STATUS_NOACCESS`Access denied to low level communication device
- `DC_STATUS_TIMEOUT` Communication to device timed out most of the time this indicated a transport issue or the device could not be found
- `DC_STATUS_IO` An IO error
- `DC_STATUS_PROTOCOL` Encountered unexpected data while communicating
- `DC_STATUS_DATAFORMAT` Encountered unexpected data while interpreting data contents
- `DC_STATUS_CANCELLED` Operation cancelled by user cancellation

### Iterators

A common pattern in libdivecomputer is the use of iterators to iterate over a sets of data. Examples are iterating over the supported device descriptors, or available devices in a transport. Commonly you have a function which initializes a iterator by reference, which you can use to iterate with `dc_status_t dc_iterator_next(dc_iterator_t *iter, void *data)`, the `data` parameter is filled with the data you try to iterate and it's type depends on the type of iterator. It is set by reference so do note to give it a reference. After the iteration is done you can clean it up with `dc_status_t dc_iterator_free(dc_iterator_t *iter)`

The return value of `dc_iterator_next` is `dc_status_t` as described earlier. On the last value it will return `DC_STATUS_DONE` to indicate the iterator is done.

A common pattern is to iterate the iterator in a while look shown in the example

```c
/**
 * Based on: https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/dctool_list.c
 */
dc_iterator_t *iterator = NULL;
dc_descriptor_t *descriptor = NULL;
dc_status_t status;
dc_descriptor_iterator (&iterator);
while ((status = dc_iterator_next(iterator, &descriptor)) == DC_STATUS_SUCCESS) {
    printf(
        "%s %s\n",
        dc_descriptor_get_vendor (descriptor),
        dc_descriptor_get_product (descriptor)
    );
    dc_descriptor_free (descriptor);
}
dc_iterator_free (iterator);

return status != DC_STATUS_DONE;

```

## Creating context

See `man dc_context_new` or [this page](https://www.libdivecomputer.org/doc/dc_context_new.3.html).

One of the first steps to using libdivecomputer is creating a `dc_context_t` for logging. It is a common required parameter for many functions and thus a logical step to start. You can create a new context with `dc_status_t dc_context_new(dc_contect **context_ptr)` and clean it up afterwards with `dc_status_t dc_context_free(dc_context_t *context_ptr)`. It is not required to provide the same `dc_context_t` to seperate functions and you can change the loglevel dynamicly as seen below.

### Log level

To change the log verbosity call `dc_status_t dc_context_set_loglevel(dc_context_t *context_ptr, dc_loglevel_t loglevel)` which accepts the `dc_context_t` to set the loglevel of and a loglevel `dc_loglevel_t.
The `dc_loglevel_t` this can have the following values

- `DC_LOGLEVEL_NONE` 
- `DC_LOGLEVEL_ERROR`
- `DC_LOGLEVEL_WARNINGS`
- `DC_LOGLEVEL_INFO`
- `DC_LOGLEVEL_DEBUG`
- `DC_LOGLEVEL_ALL`

These values each increase the logging, to when setting it to `DC_LOGLEVEL_INFO`the context will also provide logging for warnings and errors as well as info messages.

### Log function

To receive the log messages a callback function needs to be set with `dc_status_t dc_context_set_logfunc(dc_context_t *ctx, dc_logfunc_t *func, void *userdata)`where the context_ptr is of type `dc_context_t *` and refers to the context to set the loglevel of. The func is a function pointer of type `func*(dc_context_t *ctx, dc_loglevel_t loglevel, const char *file, unsigned int line, const char *function, const char *message, void *userdata)`and lastly the userdata is a pointer to any data you want to access in you logfunc callback, this userdatais given as `userdata`.

### Example

```c
/**
 * Based on https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/common.c
 */
#include <libdivecomputer/context.h>

static void
logfunc (dc_context_t *context, dc_loglevel_t loglevel, const char *file, unsigned int line, const char *function, const char *msg, void *userdata)
{
	const char *loglevels[] = {"NONE", "ERROR", "WARNING", "INFO", "DEBUG", "ALL"};

	if (loglevel == DC_LOGLEVEL_ERROR || loglevel == DC_LOGLEVEL_WARNING) {
		printf ("%s: %s [in %s:%d (%s)]\n", loglevels[loglevel], msg, file, line, function);
	} else {
		printf ("%s: %s\n", loglevels[loglevel], msg);
	}
}

int main(int argc, char *argv) {
    dc_context_t *ctx = NULL;
    dc_status_t status;
    int return_value = 0;

    status = dc_context_new(&ctx);
    if(status != DC_STATUS_SUCCESS) {
        return_value = 1;
        goto cleanup;
    }

    status = dc_context_set_loglevel(ctx, DC_LOGLEVEL_WARNINGS);
    if(status != DC_STATUS_SUCCESS) {
        return_value = 1;
        goto cleanup;
    }

    status = dc_context_set_logfunc(ctx, logfunc, NULL)
    if(status != DC_STATUS_SUCCESS) {
        return_value = 1;
        goto cleanup;
    }

    // other code

cleanup:
    dc_context_free(context);

    return return_value;
}
```

## Selecting descriptors

See `man dc_descriptor_iterator` or [this page](https://www.libdivecomputer.org/doc/dc_descriptor_iterator.3.html).

After creating a context next up is selecting a device you would like to download dives from. Initially this is done by selecting a descriptor of type `dc_descriptor_t`. This is a descriptive representation of the device supported by libdivecomputer. One way of selecting it is by iterating through the supported devices and selecting the one you want. To create an descriptor iterator use `dc_device_iterator`

The descriptor can be used to display certain information about the device, for instance getting the vendor name with `const char* dc_descriptor_get_vendor(dc_descriptor_t *descr)`, or the name of the divecomputer with `const char* dc_descriptor_get_product(dc_descriptor_t *descr)` . And for the next step, getting the supported transports with `unsigned int dc_descriptor_get_transports(dc_descriptor_t *descr)`.

### Example

This is a modified version of the example seen in the iterators section

```c
#include <string.h>
#include <libdivecomputer/descriptor.h>

/**
 * Based on https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/common.c
 */
dc_status_t get_descriptor(
    dc_descriptor_t **out,
    const char *name
) {
    dc_iterator_t *iterator = NULL;
    dc_descriptor_t *descriptor = NULL;
    dc_descriptor_t *current = NULL;
    dc_status_t status;

    dc_descriptor_iterator (&iterator);
    while ((status = dc_iterator_next(iterator, &descriptor)) == DC_STATUS_SUCCESS) {
        const char *vendor = dc_descriptor_get_vendor (descriptor);
        const char *product = dc_descriptor_get_product (descriptor);
        
        size_t n = strlen (vendor);
		if (
            strncasecmp (name, vendor, n) == 0 && name[n] == ' ' &&
			strcasecmp (name + n + 1, product) == 0
        ) {
            current = descriptor;
            // do not free the descriptor you want to use after this function
        } else {
            dc_descriptor_free (descriptor);
        }
    }
    dc_iterator_free (iterator);

    *out = current;

    return status;
}
```

## Selecting transport

(Currently no documentation available)

After creating a logging context and selecting a target device descriptor, you want to select a transport type to download the data from the device of. 
First of, not all devices support all transports. To determine which transports are usable for a given descriptor you use `unsigned int dc_descriptor_get_transports(dc_descriptor_t *descr)` which will give you a combined flag of all supported transports. To check if a device supports for instance a USBHID transport you use `dc_descriptor_get_transports(dc_descriptor_t *descr) & DC_TRANSPORT_USBHID` where `DC_TRANSPORT_USBHID` is of type `dc_transport_t`. 

Available transports are:

- DC_TRANSPORT_USBHID
- DC_TRANSPORT_USB
- DC_TRANSPORT_BLUETOOTH
- DC_TRANSPORT_BLE
- DC_TRANSPORT_IRDA 
- DC_TRANSPORT_SERIAL
- DC_TRANSPORT_NONE


## Selecting source Device

After selecting a transport you need to list the available sources. If you have multiple devices plugged in, or if the transport type doesn't support the detection of the specific device. 

### Iterating transport devices

(currently no documentatio available. see [this page](https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/dctool_scan.c) for a complete example)

Each type of transport has it's own iterator function, all variants have the same arguments `fn(dc_iterator_t **iterator, dc_context_t *ctx, dc_descriptor_t *descriptor)` but each iterator returns a different device type. 
 
- USBHID: `dc_usbhid_iterator_new` iterates over `dc_usbhid_device_t` devices
- Serial: `dc_serial_iterator_new` iterates over `dc_serial_device_t` devices
- IRDA `dc_irda_iterator_new` iterates over `dc_irda_device_t` devices
- bluetooth `dc_bluetooth_iterator_new` iterates over `dc_bluetooth_device_t` devices

### Interfacing functions for different transports

Each device type has it's own set of interfacing functions
- `dc_usbhid_device_t` has `int dc_usbhid_device_t(dc_usbhid_device_t *dev)` and  `int dc_usbhid_device_get_vid(dc_usbhid_device_t *dev)`
- `dc_irda_device_t` has  `const char* dc_irda_device_get_name(dc_irda_device_t *device)` and `unsigned int dc_irda_device_get_address(dc_irda_device_t *device)`
- `dc_serial_device_t` has `const char* dc_serial_device_get_name(dc_serial_device_t* device)`
- `dc_bluetooth_device_t` has `const char* dc_bluetooth_device_get_name(dc_bluetooth_device_t* device)` and `dc_bluetooth_address_t dc_bluetooth_device_get_address(dc_bluetooth_device_t *)`

Some of these functions are purely for displaying, others are also required when connecting to the source.

### Connecting to the source

(currently no documentation available, see [this page](https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/common.c) as an example)

As with the iterating of transport devices for each type of transport there is a different open function. The firstly to parameters are the same for each function. The first is the output parameter setting a `dc_iostream_t`, the second is the `dc_context_t` for logging. The other parameters differ between transports. 

- USBHID: `dc_status_t dc_usbhid_open(dc_iostream_t **strm, dc_context_t* ctx, dc_usbhid_device_it*dev)`
- BLUETOOTH: `dc_status_t dc_bluebooth_open(dc_iostream_t **strm, dc_context_t* ctx, dc_bluebooth_address_t addr, unsigned int port)`
- IRDA: `dc_status_t dc_irda_open(dc_iostream_t **strm, dc_context_t *ctx, unsigned int address, unsigned int lsad)`
- Serial: `dc_status_t dc_serial_open(dc_iostream_t **strm, dc_context_t *ctx, const char *name)`

For Bluetooth you seem to require a port number, which is set to 0 in the examples used by libdivecomputer.
For IRDA you seem to require an lsad which is set to 1 in the examples used in libdivecomputer.

### Example

Example of opening an iostream with an device connected through USBHID.

For more examples see [this](https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/common.c)

```c
dc_status_t open_usb(
    dc_iostream_t **out, 
    dc_context_t *ctx, 
    dc_descriptor_t *descriptor
) {
    dc_status_t status;
    dc_iterator_t *iterator = NULL;
    dc_usbhid_device_t *device = NULL;
    dc_iostream_t *iostream = NULL;

    status = dc_usbhid_iterator_new(&iterator, ctx, descriptor);
    if(status != DC_STATUS_SUCCESS) {
        return status;
    }
    
    status = dc_iterator_next(iterator, &device);
    if(status != DC_STATUS_SUCCESS || status != DC_STATUS_DONE) {
        goto cleanup;
    }

    status = dc_usbhid_open(&iostream, ctx, device);

    *out = iostream;

    cleanup:
    dc_iterator_free(iterator);
    return status;
}

```

## Downloading Dives

After getting an iostream open through the correct transport type we can start connecting to the device and downloading actual dives.

The process for downloading gives required a few steps

- First open communications to the specific device.
- Set an event handler to handle device events 
- Optionally set an fingerprint of the last read dive to be able to skip ahead
- Optionally set a cancellation handle called upon cancelling
- Set the callback for parsed dives. This will start reading from the device.

### Opening communications

(The documentation for dc_device_open is outdated, it doesn't use iostreams yet)

First you need to open communication to the device over an given iostream by calling `dc_status_t dc_device_open(dc_device_t **out, dc_context_t *ctx, dc_descriptor_t *descr, dc_iostream_t *iostream)`. After you are done you can clean it up with `dc_device_close(dc_device_t *device)`.

### Events

See `man dc_device_set_events` or [this page](https://www.libdivecomputer.org/doc/dc_device_set_events.3.html).

After opening the device you can add an event handler, which can be used to extract several data. To set the event handler you'd use `dc_status_t dc_device_set_events(dc_device_t *device, unsigned int accepted_events, dc_event_callback_t callback, void *userdata)`. The `accepted_events` is an flag combination of `dc_event_type_t` which is described below. The `callback` is of type `(*func)(dc_device_t* device, dc_event_type_t type, const void* data, void* userdata)`. The userdata is provided to the callback. The callback is called with the current event `type` , which is one of the values described below. the `data` is filled depending on the `type` and the `userdata` is provided when setting the event handler 

These are the values for `dc_event_t` with their data

- `DC_EVENT_WAITING` No data set
- `DC_EVENT_CLOCK` data set to `dc_event_clock_t` returns the device clock and the local system clock as `devtime` and `systime`. Usefull for correcting time if needed.
- `DC_EVENT_PROGRESS` data set to `dc_event_progress_t *` which holds the current download progress with a current and maximum as unsigned integer. `(current / maximum) = progress percentage`
- `DC_EVENT_DEVINFO` data set to `dc_event_devinfo_t *` which hold information about the device like the  model number, firmware number, and serial number. 
- `DC_EVENT_VENDOR` data set to `dc_event_vendor_t *` which holds the vendor name.

### Reading dives

See `man dc_device_foreach` or [this page](https://www.libdivecomputer.org/doc/dc_device_foreach.3.html).

To actually read the dive information you'd call `dc_status_t dc_device_foreach(dc_device_t *device, dc_dive_callback_t callback, void *userdata)` , the userdata is again used and given for the callback. the callback is of type ` (*func)(const unsigned char *data, unsigned int size, const unsigned char *fingerprint, unsigned int fsize, void *userdata)` where the `data` is the raw data, `size` the size of the raw data, `fingerprint` the fingerprint in this dive, `fsize` the size of the fingerprint and userdata the data given in the setter. 

The data given is a raw representation, in the `parsing dives` section you will use that raw data to parse the dive into a more structured form.
 
### Fingerprint

See `man dc_device_set_fingerprint` or [this page](https://www.libdivecomputer.org/doc/dc_device_set_fingerprint.3.html).

Each dive has a fingerprint to identify that specific dive. This fingerprint can be used to skip ahead the reading of dives and can be used to read in dives "newer" than the dive associated with the given fingerprint.
To set a fingerprint use `dc_status_t dc_device_set_fingerprint(dc_device_t *device, const unsigned char data[], unsigned int size)` where the `data` is the fingerprint data and the `size` is the fingerprint size. The fingerprint can be set after the DC_EVENT_DEVINFO event.

### Cancellation

See `man dc_device_set_cancel` or [this page](https://www.libdivecomputer.org/doc/dc_device_set_cancel.3.html).

After each "safe" point in the protocol libdivecomputer checks the cancel handler to determine if it should cancel.

To set the cancel handler call `dc_status_t dc_device_set_cancel(dc_device_t *device, dc_cancel_callback_t cb, void* userdata)`, where the `userdata` is user data given when invoking the callback. The callback is of type `(*func)(void *userdata)`

### Example

In this example a device will be opened and read. Nothing is yet done with the data. Normally you would parse the data and put it into an aggregation structure 

```c

void dive_events(
    dc_device_t* device,
    dc_event_type_t type,
    const void* data,
    void* userdata
) {
    switch(type) {
        case DC_EVENT_WAITING:
            printf("Waiting on device\n");
            break;
        case DC_EVENT_PROGRESS:
            printf("%u / %u\n", ((dc_event_progress_t*)data)->current,((dc_event_progress_t*)data)->maximum );
        // can handle more cases if needed
    }
}

void dive_data(
    const unsigned char *data,
    unsigned int size,
    const unsigned char *fingerprint,
    unsigned int fsize,
    void *userdata
) {
    printf("Received data, size=%u", size);
    for (unsigned int i = 0; i < fsize; ++i)
        printf("%02X", fingerprint[i]);
    printf("\n");
}

dc_status_t get_dives(
    dc_context_t *ctx,
    dc_descriptor_t *descr,
    dc_iostream_t *iostream
) {
    dc_device_t *device;
    dc_status_t status;
    unsigned int all_events = DC_EVENT_WAITING|DC_EVENT_PROGRESS|DC_EVENT_VENDOR|DC_EVENT_DEVINFO|DC_EVENT_CLOCK;

    status = dc_device_open(&device, ctx, descr, iostream);
    if(status != DC_STATUS_SUCCESS) {
        goto cleanup;
    }

    status = dc_device_set_events(device, all_events, dive_events, null);
    if(status != DC_STATUS_SUCCESS) {
        goto cleanup;
    }

    status = dc_device_foreach(device, dive_data, null);
    if(status != DC_STATUS_SUCCESS) {
        goto cleanup;
    }

    cleanup:
    dc_device_close(device);

    return status;
}

```

## Parsing Dives

See `man dc_parser_new` or [this page](https://www.libdivecomputer.org/doc/dc_parser_new.3.html).

As seen in the previous example, dives are given as raw binary data. Data from the dive computer is parsed with the `dc_parser_t` and this can be created with the `dc_status_t dc_parser_new(dc_parser_t **out, dc_device_t *device)` function. After creating the parser you can add data to it with `dc_status_t dc_parser_set_data(dc_parser_t *parser, const unsigned char *data, unsigned int size)`, the `data` and `size` are given in the `dc_device_foreach` callback. 
After you are done parsing , use `dc_status_t dc_parser_destroy(dc_parser_t *parser)` to cleanup the parser and it's data.

### Accessing data

See `man dc_parser_get_field` or [this page](https://www.libdivecomputer.org/doc/dc_parser_get_field.3.html).

To access the dive data in a structured way you would call  `dc_status_t dc_parser_get_field(dc_parser_t *parser, dc_field_type_t type, unsigned int flags, void *value)`. This will set a value from the dive data into the `value` reference. The type of `value` and the meaning of `flags`, depends on the `type`.

These are the available `types` and their `value` typings (for a more detailed description, see the manual referenced above).

- `DC_FIELD_DIVETIME`: Duration of the dive in seconds. Value is an `unsigned int`.
- `DC_FIELD_MAXDEPTH`: Maximum depth in metres. Value is an `double`.
- `DC_FIELD_AVGDEPTH`: Average depth in metres. Value is an `double`.
- `DC_FIELD_GASMIX_COUNT`: Number of gas mixes used in the dive. Value is an `unsigned int`.
- `DC_FIELD_GASMIX` Gets a gas mixture information. Value is `dc_gasmix_t` and holds fields as `oxygen`, `helium` and `nitrogen` which are all doubles. The `flags` field is used as the gas mixture index from 0 to DC_FIELD_GASMIX_COUNT
- `DC_FIELD_SALINITY`: The water salinity, value is of type `dc_salinity_t` which holds a `dc_water_t type` which is `DC_WATER_FRESH` or `DC_WATER_SALT` and a `double density` 
- `DC_FIELD_ATMOSPERIC`: the atmosperic pressure in bar. Value is a `double`
- `DC_FIELD_TEMPERATURE_SURFACE`: surface temperature in celsius. value is a `double`
- `DC_FIELD_TEMPERATURE_MINIMUM`: the minimum measured temperature in celsius. Value is a `double`
- `DC_FIELD_TEMPERATURE_MAXIMUM`: the maximum measured temperature in celsius. Value is a `double`
- `DC_FIELD_TANK_COUNT`: the number of thanks. Value is an `unsigned int`
- `DC_FIELD_TANK`: the tank information. Value is `dc_tank_t` which holds fields as `gasmix` which is the index of the gas mixture used, retrieved with `DC_FIELD_GASMIX`. `type` which is the volume metric `DC_TANKVOLUME_METRIC`, `DC_TANKVOLUME_IMPERIAL` or `DC_TANKVOLUME_NONE`, see the manpage for more information. `volume` holds the tank volume in liters. `workingpressure`, `beginpressure` and `endpressure` are pressures given in bar.
- `DC_FIELD_DIVEMODE` Mode of dive, either `DC_DIVEMODE_FREEDIVE`, `DC_DIVEMODE_GAUGE`, `DC_DIVEMODE_OC`, `DC_DIVEMODE_CCR` or `DC_DIVEMODE_SCR`.

If te function returns `DC-STATUS_UNSUPPORTED` the dive computer doesn support the field and thus cannot be used.

### Samples

See `man dc_parser_samples_foreach` or [this page](https://www.libdivecomputer.org/doc/dc_parser_samples_foreach.3.html).


Besides information about the whole dive, most dive computers also provide samples. These can be accessed with `dc_status_t dc_parser_samples_foreach(dc_parser_t *parser, dc_sample_callback_t callback, void *userdata)`. The `dc_sample_callback_t` is of type `(*func)(dc_sample_type_t type, dc_sample_value_t value, void *userdata)` where the `type` dictates which field of the union type `value` can be used to extract the correct data. The `userdata` is the user provided data.

The sample are provided as a sequence, each time you encounter the type `DC_SAMPLE_TIME` it is the beginning of a new sequence.

The `type` can have the following values (for a more detailed description, see the manual referenced above).

- `DC_SAMPLE_TIME` The time in seconds after the dive began, set in the `time` field as `unsigned int`.
- `DC_SAMPLE_DEPTH` The depth in metres , set in the `depth` field as `double`
- `DC_SAMPLE_PRESSURE` The tank pressure, set in the `pressures` field as `struct { unsigned int tank; double value; }` where te `tank` is the tank index retrieved from `DC_FIELD_TANK` in the `dc_parser_get_field` function. The `value` is the pressure in bar. 
- `DC_SAMPLE_TEMPERATURE` The temperature in celsius, set in the `temperature` field as `double`. 
- `DC_SAMPLE_EVENT` An event occurred, set in the `event` field. See the manpage for more information.
- `DC_SAMPLE_RBT` The remaining bottom time in seconds, set in `rbt` field as `unsigned int`
- `DC_SAMPLE_HEARTBEAT` the divers heartbeat in beats per minute, set in the `heartbeat` field as  `unsigned int`
- `DC_SAMPLE_BEARING` the bearing / heading in degrees , set in the `bearing` as `unsigned int`
- `DC_SAMPLE_VENDOR` A vendor specific field.
- `DC_SAMPLE_SETPOINT` A setpoint (PO2) has changed in bar, set in the `setpoint` field as `double`
- `DC_SAMPLE_PPO2` The PPO2 (partial pressure of oxygen) has changed in bar, sets the `ppo2` field as `double`.
- `DC_SAMPLE_CNS` The CNS (central nervous system oxigen toxicity) as a unit fraction , set in `cns` as a `double`
- `DC_SAMPLE_DECO` Decompression phase. See man page for more information.
- `DC_SAMPLE_GASMIX` Switches to a given gas mixture. Set in the `gasmix` field. This is the index of the gas mixture which can be seen in `DC_FIELD_GASMIX` in `dc_parser_get_field`.

### Example

static void dive_sample(dc_sample_type_t type, dc_sample_value_t value, void *userdata) {
    switch(type) {
        case DC_SAMPLE_TIME:
            printf("\n");
            printf("time: %u; ", value.time);
            break;
        case DC_SAMPLE_DEPTH:
            printf("depth: %f; ", value.depth);
            break;
        case DC_SAMPLE_TEMPERATURE:
            printf("temp: %f; ", value.temperature);
            break;
    }
}

void dive_parse(dc_device_t *device, const unsigned char *data, unsigned int size, const unsigned char *fingerprint, unsigned int fsize) {
    unsigned int divetime;
    double max_depth;


    printf("\n\n Dive: ");
    for (unsigned int i = 0; i < fsize; ++i)
        printf("%02X", fingerprint[i]);
    printf("\n");

    dc_parser_t *parser;
    dc_parser_new(&parser, device);

    dc_parser_set_data(parser, data, size);

    dc_parser_get_field(parser, DC_FIELD_DIVETIME, &divetime);
    dc_parser_get_field(parser, DC_FIELD_MAXDEPTH, &max_depth);

    printf("Max depth: %f\n", max_depth);
    printf("Dive time: %u seconds\n", divetime);
    
    printf("Samples:\n");
    dc_parser_samples_foreach(parser, dc_sample, NULL);

    dc_parser_destroy(parser);
}

## Cleanup

After most calls you would need to remember to cleanup and call a destroy, close or free call. For instance, when you are  done with a descriptor, remember to call `dc_descriptor_free`. And when done reading a device, remember to call `dc_device_close` and `dc_iostream_close`.
If you do not clean up properly you will leak memory.

## Putting it all together

See [this](https://github.com/libdivecomputer/libdivecomputer/blob/master/examples/) file for a full working example. 

For an example of listing descriptors see  `dctool_list.c`
For a downloading example see `dctool_download.c`. 
For an example to get data out of the parser see `output_xml.c`

